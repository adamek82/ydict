[33mcommit 57503c0cc39169c1130b35be460cdb1938b5731d[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmaster[m[33m, [m[1;31morigin/master[m[33m)[m
Author: adamek82 <amichalski@gmail.com>
Date:   Tue Dec 30 22:14:41 2025 +0100

    Load YDP .idx word index (smoke test)
    
    Implement initial IDX parsing (little-endian) in Dictionary::init():
    - verify magic (0x8d4e11d5)
    - read word count + index table offset
    - parse word entries (word + .dat offset)
    
    Expose wordCount()/wordAt() for quick validation and print first entries from app.
    This is an early reconnaissance step to confirm the file format before adding .dat reading and definition parsing.

[1mdiff --git a/src/ydict/main.cpp b/src/ydict/main.cpp[m
[1mindex 758299d..0cf2792 100644[m
[1m--- a/src/ydict/main.cpp[m
[1m+++ b/src/ydict/main.cpp[m
[36m@@ -4,11 +4,21 @@[m
 int main()[m
 {[m
     ydict::Dictionary dict;[m
[31m-    ydict::Config cfg; // empty for now[m
[32m+[m[32m    ydict::Config cfg;[m
[32m+[m
[32m+[m[32m    cfg.idx_path = "C:/Download/ydpdict/data/dict100.idx";      // TODO: For now, hardcoded for testing[m
 [m
     const bool ok = dict.init(cfg);[m
     std::cout << "init() => " << (ok ? "OK" : "FAIL") << "\n";[m
     std::cout << dict.version() << "\n";[m
 [m
[32m+[m[32m    if (ok) {[m
[32m+[m[32m        for (int i = 0; i < dict.wordCount() && i < 25; ++i) {[m
[32m+[m[32m            const auto* e = dict.wordAt(i);[m
[32m+[m[32m            std::cout << "  [" << i << "] datOffset=" << e->dat_offset[m
[32m+[m[32m                      << " word=\"" << e->word << "\"\n";[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
     return ok ? 0 : 1;[m
 }[m
[1mdiff --git a/src/ydict/ydict.cpp b/src/ydict/ydict.cpp[m
[1mindex 119332f..1baef07 100644[m
[1m--- a/src/ydict/ydict.cpp[m
[1m+++ b/src/ydict/ydict.cpp[m
[36m@@ -1,17 +1,91 @@[m
 #include "ydict/ydict.h"[m
 [m
[32m+[m[32m#include <fstream>[m
[32m+[m
 namespace ydict {[m
 [m
[31m-bool Dictionary::init(const Config& /*cfg*/)[m
[32m+[m[32mstatic std::uint16_t read_u16_le(std::istream& in)[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned char b[2]{};[m
[32m+[m[32m    in.read(reinterpret_cast<char*>(b), 2);[m
[32m+[m[32m    return static_cast<std::uint16_t>(b[0] | (std::uint16_t(b[1]) << 8));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic std::uint32_t read_u32_le(std::istream& in)[m
 {[m
[31m-    // Mock: pretend everything is OK[m
[32m+[m[32m    unsigned char b[4]{};[m
[32m+[m[32m    in.read(reinterpret_cast<char*>(b), 4);[m
[32m+[m[32m    return (std::uint32_t(b[0])      ) |[m
[32m+[m[32m           (std::uint32_t(b[1]) <<  8) |[m
[32m+[m[32m           (std::uint32_t(b[2]) << 16) |[m
[32m+[m[32m           (std::uint32_t(b[3]) << 24);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic std::string read_cstr(std::istream& in)[m
[32m+[m[32m{[m
[32m+[m[32m    std::string s;[m
[32m+[m[32m    for (;;) {[m
[32m+[m[32m        const int c = in.get();[m
[32m+[m[32m        if (c == EOF || c == 0) break;[m
[32m+[m[32m        s.push_back(static_cast<char>(c));[m
[32m+[m[32m    }[m
[32m+[m[32m    return s;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool Dictionary::init(const Config& cfg)[m
[32m+[m[32m{[m
[32m+[m[32m    initialized_ = false;[m
[32m+[m[32m    words_.clear();[m
[32m+[m
[32m+[m[32m    if (cfg.idx_path.empty())[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    std::ifstream idx(cfg.idx_path, std::ios::binary);[m
[32m+[m[32m    if (!idx)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    constexpr std::uint32_t kIdxMagic = 0x8d4e11d5;[m
[32m+[m
[32m+[m[32m    const std::uint32_t magic = read_u32_le(idx);[m
[32m+[m[32m    if (!idx || magic != kIdxMagic)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    idx.seekg(8, std::ios::beg);[m
[32m+[m[32m    const std::uint16_t count = read_u16_le(idx);[m
[32m+[m[32m    if (!idx)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    idx.seekg(16, std::ios::beg);[m
[32m+[m[32m    const std::uint32_t tableOffset = read_u32_le(idx);[m
[32m+[m[32m    if (!idx)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    idx.seekg(tableOffset, std::ios::beg);[m
[32m+[m[32m    if (!idx)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    words_.reserve(count);[m
[32m+[m
[32m+[m[32m    for (std::uint32_t i = 0; i < count; ++i) {[m
[32m+[m[32m        idx.seekg(4, std::ios::cur); // skip unknown 4 bytes[m
[32m+[m[32m        const std::uint32_t datOffset = read_u32_le(idx);[m
[32m+[m[32m        const std::string word = read_cstr(idx);[m
[32m+[m
[32m+[m[32m        if (!idx)[m
[32m+[m[32m            return false;[m
[32m+[m
[32m+[m[32m        words_.push_back(WordEntry{word, datOffset});[m
[32m+[m[32m    }[m
[32m+[m
     initialized_ = true;[m
     return true;[m
 }[m
 [m
 std::string Dictionary::version() const[m
 {[m
[31m-    return initialized_ ? "ydict (mock) - initialized" : "ydict (mock) - not initialized";[m
[32m+[m[32m    if (!initialized_)[m
[32m+[m[32m        return "ydict - not initialized";[m
[32m+[m[32m    return "ydict - idx loaded (" + std::to_string(words_.size()) + " words)";[m
 }[m
 [m
 } // namespace ydict[m
[1mdiff --git a/src/ydict/ydict.h b/src/ydict/ydict.h[m
[1mindex 68f574d..1222a0b 100644[m
[1m--- a/src/ydict/ydict.h[m
[1m+++ b/src/ydict/ydict.h[m
[36m@@ -1,27 +1,35 @@[m
 #pragma once[m
 [m
[32m+[m[32m#include <cstdint>[m
 #include <string>[m
[32m+[m[32m#include <vector>[m
 [m
 namespace ydict {[m
 [m
 struct Config {[m
[31m-    // Placeholder for future paths/settings[m
     std::string dat_path;[m
     std::string idx_path;[m
 };[m
 [m
[32m+[m[32mstruct WordEntry {[m
[32m+[m[32m    std::string word;[m
[32m+[m[32m    std::uint32_t dat_offset = 0;[m
[32m+[m[32m};[m
[32m+[m
 class Dictionary {[m
 public:[m
[31m-    Dictionary() = default;[m
[31m-[m
[31m-    // Mock init for now; later: open files, read index, etc.[m
     bool init(const Config& cfg);[m
 [m
[31m-    // Mock: just to validate linkage/calls[m
     std::string version() const;[m
 [m
[32m+[m[32m    int wordCount() const { return static_cast<int>(words_.size()); }[m
[32m+[m[32m    const WordEntry* wordAt(int i) const {[m
[32m+[m[32m        return (i >= 0 && i < static_cast<int>(words_.size())) ? &words_[i] : nullptr;[m
[32m+[m[32m    }[m
[32m+[m
 private:[m
     bool initialized_ = false;[m
[32m+[m[32m    std::vector<WordEntry> words_;[m
 };[m
 [m
 } // namespace ydict[m
